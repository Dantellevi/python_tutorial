import pandas as pd

df=pd.DataFrame([
    ['зеленый','M',10.1,'класс1'],
    ['красный','L',13.5,'класс2'],
    ['синий','XL',15.3,'класс1']
])      #генерируем данные

df.columns=['цвет','размер','цена','метка'] #метка класса

print(df)

#========================Преобразование порядковых признаков==============

size_mapping={#словарь соответствий

    'XL':3,
    'L':2,
    'M':1
}

df['размер']=df['размер'].map(size_mapping)
print(df)



#===============================Кодирование меток классов==============

import numpy as np

class_mapping={label: idx for idx,label in enumerate(np.unique(df['метка']))}

print(class_mapping)

"""
Для того чтобы вернуть преобразованные метки классов назад в первоначальное 
строковое представление, пары ключ-значение в словаре соответствий можно ин­
вертировать следующим образом: 
"""

inv_class_mapping={v:k for k,v in class_mapping.items()}
df['метка']=df['метка'].map(inv_class_mapping)

"""
Как вариант непосредственно в самой библиотеке scikit-learn реализован вспомо­
гательный класс LabelEncoder, который выполняет то же самое: 
"""
from sklearn.preprocessing import LabelEncoder
class_le=LabelEncoder()

y=class_le.fit_transform(df['метка'].values)

print(y)


#============================Прямое кодирование на номинальных признаках========

"""
В предыдущем разделе для перевода значений порядкового признака «размер~> 
в целочисленные мы использовали простой подход на основе словаря соответствий. 
Поскольку оценщики библиотеки scikit-learn рассматривают метки классов без ка­
кого-либо порядка, мы использовали вспомогательный класс LabelEncoder для ко­
дирования строковых меток в целые числа. Может показаться, что аналогичный 
подход можно использовать и для преобразования столбца «цвет» с номинальными 
значениями, как показано ниже: 

"""

X=df[['цвет','размер','цена']].values
color_le=LabelEncoder()
X[:,0]=color_le.fit_transform(X[:,0])

print(X)


"""
Несмот­
ря на то что значения цвета не идут
 в том или ином конкретном порядке, алгоритм 
обучения теперь предположит, что зеленый больше синего, а красный больше зелеио­
zо. Хотя это допущение является неправильным, алгоритм все равно способен про­
извести полезные результаты. Однако эти результаты не будут оптимальными. 
Общее обходное решение этой проблемы состоит в использовании метода, кото­
рый называется прямым кодированием1.  В основе этого подхода лежит идея, кото­
рая состоит в том,  чтобы в столбце номинального признака создавать новый фиктив­
ный признак для каждого уникального значения. В данном случае признак «цвет» 
можно преобразовать в три новых признака: синий, зеленый и красный.  Затем 
можно использовать двоичные значения для указания отдельно взятого цвета об­
разца;  например, синий образец может быть закодирована как синий=l, зеленый=О, 
красный=О. Для выполнения этого преобразования можно воспользоваться классом 
OneHotEncoder, который реализован в модуле scikit-learn.preprocessing: 
"""

from sklearn.preprocessing import OneHotEncoder
ohe=OneHotEncoder(categorical_features=[0])
ohe.fit_transform(X).toarray()


#=============================================================================



