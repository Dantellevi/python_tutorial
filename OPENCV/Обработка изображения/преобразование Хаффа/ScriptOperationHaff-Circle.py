

import numpy as np
import cv2


img=cv2.imread('Origin.JPG',0)

#считывание данных
img_blur=cv2.medianBlur(img,5)                                              #размытие с коэффициентом 5
#gray=cv2.cvtColor(img_blur,cv2.COLOR_BGR2GRAY)                              #преобразование в серый




"""
Python: cv2.HoughCircles( образ, метод, dp, minDist [ , круги [ , param1 [ , param2 [ , minRadius [ , maxRadius ] ] ] ] ] ) → круги 
Параметры:	
image - 8-битное, одноканальное, полутоновое входное изображение.
круги - выходной вектор найденных кругов. Каждый вектор кодируется как 3-элементный вектор с плавающей запятой  (x, y, радиус).
circle_storage - в функции C это память, которая будет содержать выходную последовательность найденных кругов.
метод - метод обнаружения. В настоящее время единственным реализованным методом является CV_HOUGH_GRADIENT, в основном, 21HT , описанным в [Yuen90] .
dp - Обратное отношение разрешения аккумулятора к разрешению изображения. Например, если dp=1аккумулятор имеет такое же разрешение, как и входное изображение. Если dp=2аккумулятор имеет половину ширины и высоты.
minDist - Минимальное расстояние между центрами обнаруженных кругов. Если параметр слишком мал, несколько соседних окружностей могут быть ложно обнаружены в дополнение к истинному. Если он слишком велик, некоторые круги могут быть пропущены.
param1 - Первый параметр, специфичный для метода. В случае CV_HOUGH_GRADIENT, если верхний порог двух передан на Canny() краевой детектор (нижний - в два раза меньше).
param2 - Второй параметр, специфичный для метода. В случае CV_HOUGH_GRADIENT, это порог аккумулятора для центров окружности на этапе обнаружения. Чем меньше это, тем более ложные круги могут быть обнаружены. Круги, соответствующие большим значениям аккумулятора, будут возвращены первыми.
minRadius - Минимальный радиус круга.
maxRadius - Максимальный радиус круга.
"""
circles = cv2.HoughCircles(img_blur,cv2.HOUGH_GRADIENT,1,20,
                            param1=50,param2=30,minRadius=0,maxRadius=0)#распознавание окружностей


circles = np.uint16(np.around(circles))         #округление с преобразованием
for i in circles[0,:]:          #проходим по матрице и извлекаем центры и радиусы найденных окружностей
    # draw the outer circle
    cv2.circle(img_blur,(i[0],i[1]),i[2],(0,255,0),2)       #чертим окружности
    # draw the center of the circle
    cv2.circle(img_blur,(i[0],i[1]),2,(0,0,255),3)

cv2.imshow('detected circles',img_blur)
cv2.waitKey(0)
cv2.destroyAllWindows()
