#Сопоставление функций (гомография)
import cv2
import numpy as np
import matplotlib.pyplot as plt


#-----------------------------------------------------------
#читаем шаблон
img1=cv2.imread('opencv-feature-matching-template.jpg', 0)

#читаем изображение на катором будем искать шаблон
img2=cv2.imread('opencv-feature-matching-image.jpg' , 0)

#-----------------------------------------------------------
#Initiate ORB detector
#
# ORB - это, в основном, слияние детекторов ключевых
# слов FAST и дескриптор BRIEF
# со многими модификациями для повышения производительности.

orb=cv2.ORB_create()
#--------------------------------------------
#Это детектор, который мы
#  будем использовать для этих функций.
#Здесь мы находим ключевые точки
#  и их дескрипторы с детектором орба.

kp1, des1=orb.detectAndCompute(img1,None)
kp2, des2=orb.detectAndCompute(img2,None)
#---------------------------------------------

#Brute-Force проста. Он берет дескриптор одной функции в первом наборе
#  и сопоставляется со всеми другими функциями во втором наборе,
#  используя некоторый расчет расстояния. И ближайший возвращается.
# Для двоичных строковых дескрипторов, таких как ORB, BRIEF, BRISK и
#  т. Д., Следует использовать cv2.NORM_HAMMING , которые использовали
#  измерение Хэмминга как измерение. Если ORB использует WTA_K == 3 или
#  4 , следует использовать cv2.NORM_HAMMING2 .

bf=cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)

#Сопоставить дескрипторы.
#Здесь мы создаем совпадения дескрипторов,
#  затем сортируем их на основе их расстояний.
matches=bf.match(des1,des2)

matches=sorted(matches,key= lambda x:x.distance)


Img3=cv2.drawMatches(img1,kp1,img2,kp2, matches[:50],None,flags=2)
plt.imshow(Img3)
plt.show()
